一、所有的子进程均在Frame.execute函数中创建并终止，所有子进程终止后等待函数终止后，完成所有回测任务
二、目前已设计进程：策略执行（子进程中执行）、绘图执行和数据更新（主进程的一个线程中运行，因为这个操作是比较耗时的）
三、策略执行（子进程）与绘图执行绘图执行和数据更新（主进程中的一个线程）直接的数据交换方法：
1、update_queue = mp.Queue()
这个队列所有元素均为元组类型，策略进程负责生成元组并放到队列中，绘图函数复制从队列中取出元组，并在队列中没有元素后进行数据的更新
元组组织结构（日期（str）， 收益率（float））
2、trade_queue = mp.Queue()
这个队列的所有元素均为字符串类型，用于显示具体的交易记录信息，一般在日志控件中显示，下面是一条交易记录的展示：
‘您旗下的xxx账户在xxxx年-xx月-xx日进行了一笔交易，卖出了A股（市场）赛里斯601127.SH（代码）10000股(股数），成交均价100CNY，总成交金额1000000CNY，目前账户可用余额1000000CNY’
‘您旗下的xxx账户在xxxx年-xx月-xx日进行了一笔挂单，卖出目标标的A股（市场）赛里斯601127.SH（代码），挂单10000股，目标价100CNY，预计成交金额1000000CNY，目前账户可用余额1000000CNY‘

为什么不能在非主线程中直接更新GUI，而必须在主线程中更新GUI？
因为大多数 GUI 库（包括 wxPython、Tkinter、Qt 等）都不是线程安全的，这意味着你不能从多个线程同时操作 GUI 元素，否则可能会导致未定义的行为。
wx.CallAfter 是 wxPython 提供的一个非常方便的方法，它可以将某个函数调用放到主线程的事件队列中，以确保该函数在主线程中执行。即使是在另一个线程中调用 wx.CallAfter，它也会把指定的函数调度到主线程来执行。